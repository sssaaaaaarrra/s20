---
layout: exam_info
num: e01
ready: false
desc: "'Midterm' Exam"
exam_date: 2020-03-04 14:00
---

# 'Midterm' Exam (75 minutes) 

Link to actual exam (this is only a placeholder until after the exam is complete, graded,
and returned): [Actual Exam](cs48_w20_e01/){:data-ajax="false"}.

## About CS48 exams

For many questions on CS exams, there are clear right and wrong answers:

* Sometimes there is one exact correct answer; all other answers are wrong.
   * e.g. "what is the output of this code"
* An algorithmic way to determine whether an answer is right or wrong
   * e.g. "write code that solves this problem"
   * For simple code, the grader can run the code in their head
   * For complex code, the grader can type it in and run it for real


There will likely be some questions like that&mdash;but not only those.

There may be a few questions about terminology and definitions
where there is one correct answer:

For example, the question:
* "In the context of Agile Software Development, what do the letters MVP typically refer to?  Hint: it isn't "most valuable player"

Then, there may be some where there's a set of things that right answers tend to mention:

* "Explain the concept of MVP in the context of Agile Software Development.  In your answer, explain what an MVP is, and the steps involved in designing and delivering an MVP"

But, then there also be questions where you have to construct an argument.   Here, there may not be a single correct answer.  Instead of being graded on "right" or "wrong", you'll be graded on whether your answer clearly supports your position with strong arguments:

* Consider "big up front design" vs. the Agile MVP approach to design.  
   * Give an example of a software project where you can argue that "big up front design" would be a better approach than the Agile MVP approach, and make your case.
   * Give an example of a software project where you can argue that the Agile MVP approach is better than "big up front design", and make your case.

There is no "one right answer" to a question such as this.   Some answers are better than others though, and it comes back to whether you make your case clearly, and citing relevant details that you've learned from the course.

## Coverage

* Homeworks {% include hwk hwk="h00" %} through {% include hwk hwk="h07" %} and reading assignments that went with those homeworks.
   * You are encouraged to re-read those; exam questions may be asked
     about topics not specifically mentioned on the homework, but that are
     major themes in the reading.
   * Note: these are not intended as "gotcha" questions about small details,
     but are designed to make sure you understood the big picture.  So focus
     on the big themes as you read.
   * A way of studying that is strongly encouraged: meet with your team, or
     with any other classmates.  Read an article together silently, or out
     loud, a section at a time.  Then try to summarize it out loud to each
     other, without looking back at the article.
   * Next level: try to imagine that you are the professor, and come up
     with questions that you would ask. Ask each other these questions.
* Lecture activities through the lecture before the exam
* Labs {% include lab lab="lab00" %} through {% include lab lab="lab05" %}
   * For the labs, the idea is to ensure that you understood the purpose
     of the various activities (user stories, issues, kanban boards, retros,
     etc.) and their role in the Agile Software Development Lifecycle (SDLC).
   * So as you study, review *what* we did, and *why* we said we did it.
   * An important Agile principle is "inspect and adapt".
   * Another is the notion that there is no "one true right way" to develop
     software; every practice has pros and cons, and represents tradeoffs.
   * So, as explained above, expect that
     the exam may ask questions that ask you to argue both for and against
     various Agile practices.   As you study, try to identify:
        * the benefits of the approach we took (pros)
	* the real or potential drawbacks (cons) of that approach
	* alternatives we could have used, and the pros/cons of those

   
